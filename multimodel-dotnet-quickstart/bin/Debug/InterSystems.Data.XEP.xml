<?xml version="1.0"?>
<doc>
    <assembly>
        <name>InterSystems.Data.XEP</name>
    </assembly>
    <members>
        <member name="T:InterSystems.XEP.Attributes.Embedded">
            <summary>
            Embedded attribute
            </summary>
        </member>
        <member name="T:InterSystems.XEP.Attributes.Index">
            <summary>
            Index Attribute
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.Index.name">
            <summary>
            Index name
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.Index.fields">
            <summary>
            Index fields
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.Index.type">
            <summary>
            Index type
            </summary>
        </member>
        <member name="T:InterSystems.XEP.Attributes.IndexType">
            <summary>
            IndexType attribute
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.IndexType.none">
            <summary>
            no index
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.IndexType.bitmap">
            <summary>
            bitmap index
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.IndexType.bitslice">
            <summary>
            bitslice index
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.IndexType.simple">
            <summary>
            simple index
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.IndexType.idkey">
            <summary>
            (compound) idkey
            </summary>
        </member>
        <member name="T:InterSystems.XEP.Attributes.Serialized">
            <summary>
            Serialized attribute
            </summary>
        </member>
        <member name="T:InterSystems.XEP.Attributes.Transient">
            <summary>
            Transient attribute
            </summary>
        </member>
        <member name="T:InterSystems.XEP.Attributes.Id">
            <summary>
            Id Attribute
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Attributes.Id.generated">
            <summary>
            System generated flag
            </summary>
        </member>
        <member name="T:InterSystems.XEP.Event">
            <summary><CODE>Event</CODE> provides methods that operate on XEP Events
            (storing events, creating a query, setting a filter, indexing etc)
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.INDEX_MODE_ASYNC_ON">
            <summary>
            Set this option to turn asynchronous indexing on (default option).
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.INDEX_MODE_ASYNC_OFF">
            <summary>
            Set this option to turn asynchronous indexing off.
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.INDEX_MODE_SYNC">
            <summary>
            Set this option to use syncronous indexing.
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.FETCH_LEVEL_ALL">
            <summary>
            Set this option to fetch all data (default option).
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.FETCH_LEVEL_DATATYPES_ONLY">
            <summary>
            Set this option to fetch only datatype data. Arrays, object types and collections
            will not be fetched.
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.FETCH_LEVEL_NO_ARRAY_TYPES">
            <summary>
            Set this option to fetch all data except arrays.
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.FETCH_LEVEL_NO_OBJECT_TYPES">
            <summary>
            Set this option to fetch all non-object data.
            </summary>
        </member>
        <member name="F:InterSystems.XEP.Event.FETCH_LEVEL_NO_COLLECTIONS">
            <summary>
            Set this option to fetch all data except collections.
            </summary>
        </member>
        <member name="M:InterSystems.XEP.Event.Close">
            <summary>Releases all resources held by this event</summary>
        </member>
        <member name="M:InterSystems.XEP.Event.Store(System.Object)">
            <summary>Stores the C# object.</summary>
            <param name="obj">C# object to be saved</param>
            <returns> long database id of the newly inserted object,
            or 0 (zero) if the database id could not be returned 
            or does not apply (for example if composite IDKEYs are used)
            NOTE: For performance reasons the TCP/IP version will always 
            return 0
            </returns>
        </member>
        <member name="M:InterSystems.XEP.Event.Store(System.Object[])">
            <summary>Stores an array of C# objects.</summary>
            <param name="objects">array of C# objects to be saved</param>
            <returns> long database ids of all newly inserted objects,
            or 0 (zeros) if composite IDKEYs are used
            </returns>
        </member>
        <member name="M:InterSystems.XEP.Event.CreateQuery``1(System.String)">
            <summary>
            Create an instance of EventQuery.
            </summary>
            <param name="sqlText">SQL query text</param>
            <returns>An instance of EventQuery</returns>
        </member>
        <member name="M:InterSystems.XEP.Event.GetObject(System.Int64)">
            <summary>Retrieves an object given its database id.
            Returns null if no object with this id exists.</summary>
            <param name="id">database id</param>
            <returns> Object an event object</returns>
        </member>
        <member name="M:InterSystems.XEP.Event.UpdateObject(System.Int64,System.Object)">
            <summary>Updates an existing object given its database id.</summary>
            <param name="id">database id</param>
            <param name="obj">new object</param>
        </member>
        <member name="M:InterSystems.XEP.Event.DeleteObject(System.Int64)">
            <summary>Deletes an object given its database id.</summary>
            <param name="id">database id</param>
        </member>
        <member name="M:InterSystems.XEP.Event.GetObject(System.Object[])">
            <summary>Gets an object given its IDKEYs.</summary>
            <param name="idkeys">composite IDKEY</param>
        </member>
        <member name="M:InterSystems.XEP.Event.UpdateObject(System.Object[],System.Object)">
            <summary>Updates an object given its IDKEYs.</summary>
            <param name="idkeys">composite IDKEY</param>
            <param name="obj">object to update</param>
        </member>
        <member name="M:InterSystems.XEP.Event.DeleteObject(System.Object[])">
            <summary>Deletes an object given its IDKEYs.</summary>
            <param name="idkeys">composite IDKEY</param>
        </member>
        <member name="M:InterSystems.XEP.Event.IsEvent(System.Object)">
            <summary>Checks whether an object (or class) is an event in the XEP sense</summary>
            <param name="objectOrClass">C# object or class object</param>
        </member>
        <member name="M:InterSystems.XEP.Event.StartIndexing">
            <summary>Start populating indexes asynchronously. This method will throw 
            an exception if called on an event created with INDEX_MODE_SYNC index mode.
            </summary>
        </member>
        <member name="M:InterSystems.XEP.Event.StopIndexing">
            <summary>Stop populating indexes asynchronously. This method will throw 
            an exception if called on an event created with INDEX_MODE_SYNC index mode.
            </summary>
        </member>
        <member name="M:InterSystems.XEP.Event.WaitForIndexing(System.Int32)">
            <summary>Wait for asynchronous indexing to be completed for this class.
            If timeout is -1, wait forever or until indexing completes, else
            timeout after the specified number of seconds, returning false if indexing has
            not completed.  If timeout is 0, immediately return true if indexing has
            completed or false if it has not. This method will throw  an exception if 
            called on an event created with INDEX_MODE_SYNC index mode.
            
            In ECP configurations, this method applies only to indexing of objects inserted
            via the current App Server.
            
            </summary>
            <param name="timeout">Seconds to wait before timing out, -1 for no timeout (wait forever)
            </param>
            <returns> true if indexing has completed, false if timed out before indexed completed
            </returns>
        </member>
        <member name="M:InterSystems.XEP.Event.ParallelStore(System.Object[],System.Int32)">
             <summary>Stores an array of C# objects taking advantage of concurrent
             utilities for potential insert performance speedup. It is important to note
             that the potential speedup would result from taking advantage of multiple 
             threads/cores to serialize the data. Once the data is serialized, the rest
             of the store process will be equally I/O bound as the ordinary version of 
             store. This method should be used only on multi-core machines. It is recommended
             that the non-parallel version of store is used to get the baseline insert
             rate numbers. Whether ParallelStore performs better depends on the particular 
             environment. Once the base line is obtained, and the number of cores is
             retrieved (for example by calling Environment.ProcessorCount, 
             it might be a good idea to experiment with different splitFactors to see if 
             using ParallelStore will result in performance boost. 
             Please note that unlike the regular version, ParallelStore does not 
             (for performance reasons) return the ids of all the objects that were inserted.
             splitFactor should always be greater than 2; otherwise regular Store method will
             be utilized. 
            
             IMPORTANT NOTES: True parallel version (utilizing DotNet 4.0 concurrent libraries
                              is only available for DotNet 4.0+). Prior versions will simply
                              call the regular Store method.
                              This method should only be used when no other threading either at
                              the application, or at the XEP level is used.
            </summary>
             <param name="objects">array of C# objects to be saved</param>
             <param name="splitFactor"> number of parallel tasks used to serialize the data</param>
        </member>
        <member name="T:InterSystems.XEP.EventPersister">
            <summary><c>EventPersister</c> is the main entry point for the XEP module.
            It provides methods that can be used to set XEP options up, establish an XEP
            connection, import schema, produce XEP <c>Event</c> objects, get an Ado.NET
            connection sharing the same process space. It also provides methods to control
            transactions and perform other tasks.
            
            </summary>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.GetAdoNetConnection">
            <summary>Returns an ADO.NET connection
            <strong>Important Note:</strong> When connecting via TCP/IP, the ADO.NET connection is
            also used by the XEP engine, so the users should be careful not to close or corrupt 
            the connection obtained by this method as that might cause the XEP engine to fail.
            </summary>
            <returns> an ADO.NET connection</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.SetInterfaceResolver(InterSystems.XEP.InterfaceResolver)">
             <summary>Sets InterfaceResolver. InterfaceResolver is only relevant when using
             the flat import mode. All Event objects created via this EventPersiser
             object will share the InterfaceResolver object. InterfaceResolver defaults
             to null if this method is not called. See documentation for more info
             on InterfaceResolver and how it should be used to inform the XEP engine
             what actual runtime types it can expect for any fields declared as interfaces.
            
             IMPORTANT: Even if set, InterfaceResolver will not be used to resolve 
                        interfaces when importing classes using the full mode.
            
             </summary>
             <param name="interfaceResolver">An implementation of InterfaceResolver</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.GetInterfaceResolver">
            <summary>Returns currently set InterfaceResolver.</summary>
            <returns> an instance of InterfaceResolver, or null if none set</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Connect(System.String,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>Connect to IRIS using the parameters specified below. This flavor is
            to be used for connecting via TCP/IP only.
            </summary>
            <param name="host">TCP/IP host address</param>
            <param name="port">TCP/IP port number</param>
            <param name="nmspace">IRIS namespace to connect to</param>
            <param name="username">username</param>
            <param name="password">password</param>
            <param name="log">log</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Connect(System.String,System.Int32,System.String,System.String,System.String)">
            <summary>Connect to IRIS using the parameters specified below. This flavor is
            to be used for connecting via TCP/IP only.
            </summary>
            <param name="host">TCP/IP host address</param>
            <param name="port">TCP/IP port number</param>
            <param name="nmspace">IRIS namespace to connect to</param>
            <param name="username">username</param>
            <param name="password">password</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Connect(System.String)">
            <summary>Connect to IRIS using the IRISADOConnection.ConnectionString specified below. This flavor is
            to be used for connecting via TCP/IP only.  By default pooling is turned on, which is different than the four
            parameter argument to Connect() which turns pooling off.
            </summary>
            <param name="connString">IRISADOConnection.ConnectionString (a set of key value pairs)</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Close">
            <summary>Close this EventPersister instance</summary>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallProcedure(System.String,System.String,System.Object[])">
            <summary>Call a COS procedure. Reference parameters (in the COS sense) 
            are not supported.</summary>
            <param name="procedureName">procedure name</param>
            <param name="routineName">routine name</param>
            <param name="args">procedure arguments</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallFunction(System.String,System.String,System.Object[])">
            <summary>Call a COS function. Reference parameters (in the COS sense) 
            are not supported.</summary>
            <param name="functionName">procedure name</param>
            <param name="routineName">routine name</param>
            <param name="args">procedure arguments</param>
            <returns> return value</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallClassMethod(System.String,System.String,System.Object[])">
            <summary>
            Calls a Cache ObjectScript class method, passing 0 or more arguments and
            returning the method's return value as an instance of <c>string</c>,
            <c>int</c>, <c>long</c>, or <c>double</c>.
            </summary>
            <remarks>
            Arguments may be of any of the types <c>string</c>,
            <c>int</c>, <c>long</c>, <c>double</c> or <c>byte[]</c>. Trailing arguments
            may be omitted, causing default values to be used for those arguments,
            either by passing fewer than the full number of arguments, or by
            passing <c>null</c> for trailing arguments. Throws an exception
            if a non-null argument is passed to the right of a null argument.
            <p>
            To call a IRIS class method which does not return a value, use
            <see cref="M:InterSystems.XEP.EventPersister.CallVoidClassMethod(System.String,System.String,System.Object[])"/>.
            </p></remarks>
            <param name="className"> fully qualified name of the IRIS class
            to which the called method belongs.</param>
            <param name="methodName"> name of the IRIS class method.</param>
            <param name="args"> 0 or more arguments to pass to the method.</param>
            <returns> the value returned by the IRIS ObjectScript class method, as an 
            instance of <c>string</c>, <c>int</c>, <c>long</c> or <c>double</c>.
            </returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallVoidClassMethod(System.String,System.String,System.Object[])">
            <summary>
            Calls a Cache ObjectScript class method with no return value,
            passing 0 or more arguments.
            </summary>
            <remarks>
            <p>
            Arguments may be of any of the types <c>string</c>, <c>int</c>, 
            <c>long</c>, <c>double</c> or <c>byte[]</c>. Trailing arguments
            may be omitted, causing default values to be used for those arguments,
            either by passing fewer than the full number of arguments, or by
            passing <c>null</c> for trailing arguments. Throws an exception
            if a non-null argument is passed to the right of a null argument.
            </p><p>
            This method may be used to call IRIS class methods which return no value,
            or to call IRIS class methods which do return a value, when the caller does not
            need the return value. To call IRIS class methods and get their return values,
            use <see cref="M:InterSystems.XEP.EventPersister.CallClassMethod(System.String,System.String,System.Object[])"/>.
            </p></remarks>
            <param name="className"> fully qualified name of the IRIS class to
            which the called method belongs.</param>
            <param name="methodName"> name of the IRIS class method.</param>
            <param name="args"> 0 or more arguments to pass to the method.</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallBytesClassMethod(System.String,System.String,System.Object[])">
             <summary>
             Calls a IRIS class method passing 0 or more arguments and
             returning the class method's return value as <c>byte[]</c>.
             This method is identical to {@link #CallClassMethod}, except 
             that string values are returned as instances of <c>byte[]</c>
             rather than <c>string</c>.
             Arguments may be of any of the types <c>string</c>, <c>int</c>, 
             <c>long</c>, <c>double</c>, or <c>byte[]</c>. Trailing arguments 
             may be omitted, causing  default values to be used for those 
             arguments, either by passing fewer than the full number of 
             arguments, or by passing <c>null</c> for trailing arguments. 
            
             The return value is a <c>byte[]</c>.
             To cause string values to be returned as instances of <c>string</c>
             use {@link #CallClassMethod}.
             To cause string values to be returned as instances of <c>ValueList</c>
             or <c>VList</c> use {@link #CallListClassMethod}.
             </summary>
            
             <param name="className"> fully qualified name of the IRIS class to which the called
                              method belongs.</param>
             <param name="methodName"> name of the IRIS class method.</param>
             <param name="args"> 0 or more arguments to pass to the function.</param>
             <returns> the value returned by the IRIS ObjectScript function, as byte[].</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallBytesFunction(System.String,System.String,System.Object[])">
            <summary>
            Calls a Cache ObjectScript function, passing 0 or more arguments and
            returning the function's return value as a byte[]. This method is 
            identical to {@link #CallFunction}, except that string values are 
            returned as <c>byte[]</c> rather than <c>string</c>.
            Arguments may be of any of the types <c>string</c>, <c>int</c>, 
            <c>long</c>, <c>double</c> or <c>byte[]</c>. Trailing arguments 
            may be omitted, causing  default values to be used for those 
            arguments, either by passing fewer than the full number of arguments, 
            or by passing <c>null</c> for trailing arguments. 
            
            The return value is a <c>byte[]</c>.
            To cause string values to be returned as instances of <c>string</c>
            use {@link #CallFunction}.
            To cause string values to be returned as instances of <c>ValueList</c>
            or <c>VList</c> use {@link #CallListFunction}.
            </summary>
            
            <param name="functionName"> name of the Cache ObjectScript function to call.</param>
            <param name="routineName"> name of the routine containing the function.</param>
            <param name="args"> 0 or more arguments to pass to the function.</param>
            <returns> the value returned by the Cache ObjectScript function, as a byte[].</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallListClassMethod(System.String,System.String,System.Object[])">
            <summary> Calls a IRIS class method passing 0 or more arguments and
             returning the class method's return value as an instance of
             {@link ValueList} {in-memory version) or {@link VList} (TCP/IP version)
             This method is identical to {@link #CallClassMethod}, except that 
             string values are returned as instances of <c>ValueList</c> or 
             <c>VList</c> rather than <c>string</c>, <c>int</c>, <c>long</c>, 
             <c>double</c>, or <c>byte[]</c>. Trailing arguments may be omitted, 
             causing default values to be used for those arguments, either by 
             passing fewer than the full number of arguments, or by passing 
             <c>null</c> for trailing arguments. 
             
             The return value is an instance of <c>ValueList</c> or <c>VList</c>.
             To cause string values to be returned as instances of <c>string</c>
             use {@link #CallClassMethod}.
             To cause string values to be returned as instances of <c>byte[]</c>
             use {@link #CallBytesClassMethod}.
             </summary>
            
             <param name="className"> fully qualified name of the IRIS class to which the called
                    method belongs.</param>
             <param name="methodName"> name of the IRIS class method.</param>
             <param name="args"> 0 or more arguments to pass to the function.</param>
             <returns> the value returned by the IRIS ObjectScript function, as <c>ValueList</c> 
             (in-memory version) or <c>VList</c> (TCP/IP version).</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.CallListFunction(System.String,System.String,System.Object[])">
            <summary> Calls a Cache ObjectScript function, passing 0 or more arguments and
             returning the function's return value as an instance of
             {@link ValueList} {in-memory version) or {@link VList} (TCP/IP version)
             This method is identical to {@link #CallFunction}, except that string 
             values are returned as instances of <c>VList</c> or <c>VList</c> 
             rather than <c>string</c>. Arguments may be of any of the types
             <c>string</c>, <c>int</c>, <c>long</c>, <c>double</c> or <c>byte[]</c>. 
             Trailing arguments may be omitted, causing default values to be used for 
             those arguments, either by passing fewer than the full number of arguments, 
             or by passing <c>null</c> for trailing arguments. 
             
             The return value is an instance of <c>ValueList</c> or <c>VList</c>.
             To cause string values to be returned as instances of <c>string</c>
             use {@link #CallFunction}.
             To cause string values to be returned as instances of <c>byte[]</c>
             use {@link #CallBytesFunction}.
             </summary>
             
             <param name="functionName"> name of the Cache ObjectScript function to call.</param>
             <param name="routineName"> name of the routine containing the function.</param>
             <param name="args"> 0 or more arguments to pass to the function.</param>
             <returns> the value returned by the Cache ObjectScript function, as <c>ValueList</c> 
             (in-memory version) or <c>VList</c> (TCP/IP version).</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.GetEvent(System.String)">
            <summary>Returns an event object that corresponds to the supplied class name.
            </summary>
            <param name="className">name of the C# class</param>
            <returns> an Event object</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.GetEvent(System.String,System.Int32)">
            <summary>Returns an event object that corresponds to the supplied class name.
            </summary>
            Also sets up the indexing mode to be used.
            <param name="className">name of the C# class</param>
            <param name="indexMode">index mode to be used</param>
            <returns> an Event object</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.ImportSchema(System.String)">
             <summary>If parameter is a class name, import the corresponding class
             and any dependencies. If the parameter is a DLL file, import all
             classes in the DLL file and any dependencies. As part of the import,
             the XEP engine will first try to see if the corresponding schema
             already exists on the IRIS side. If such schema already exists,
             and it appears to be in sync with the C# schema, import will be
             skipped. Should a schema already exist, but it appears different,
             a check will be performed to see if there is any data. If there is
             no data, a new schema will be generated. If there is existing data,
             an exception will be thrown. Returns an array of imported class names.
            
             Since XEP needs to know the actual (concrete) runtime types, if
             any fields are declared as interfaces, these fields will be skipped
             (ignored) by XEP by default, unless an implementation of
             InterfaceResolver has been set (by calling setInterfaceResolver).
             For any interfaces whose concrete implementation types are not found
             in the InterfaceResolver, the default behavior is applied (which means
             that the corresponding field will not be projected, nor considered in
             store/load)
            
             This flavor should be used for performance oriented applications.
             The object hierarchy will be fully flattened, and all references
             will be embedded (projected as ObjectScript serial objects). For
             applications that require richer feature set, and better correspondence
             between the C# and ObjectScript object schemas, but are not performance
             critical, one should use importSchemaFull flavor.
             </summary>
             
             <param name="classOrDLLName">name of the C# class or DLL</param>
             <returns>an array of imported class names</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.ImportSchemaFull(System.String)">
             <summary>See importSchema(String classOrJarFileName) for more info. This flavor is different 
             from that one in that it will not generate the flattened object model, and will allow
             references. While this mode allows a much closer mapping from Java to ObjectScript
             by preserving the inheritance model and projecting Java references to ObjectScript,
             using this mode will invariably result in slower performance. For performance
             oriented applications, one should use the alternative importSchema flavor.
            
             IMPORTANT: Any class to be imported in the full mode must declare a user defined
                        Id Key (use @ID for single field keys, or @Index for compound id keys).
             
             </summary>
             <param name="classOrDLLName">name of the C# class or DLL</param>
             <returns>an array of imported class names</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.ImportSchemaFull(System.String[])">
            <summary> See importSchema(String[] classes) for more info. This flavor is different from
             that one in that it will not generate the flattened object model, and will allow
             references. While this mode allows a much closer mapping from C# to ObjectScript
             by preserving the inheritance model and projecting C# references to ObjectScript,
             using this mode will invariably result in slower performance. For performance
             oriented applications, one should use the alternative importSchema flavor.
            
             IMPORTANT: Any class to be imported in the full mode must declare a user defined
                        Id Key (use @ID for single field keys, or @Index for compound id keys).
             
             </summary>
            
             <param name="classNames">class names to be imported</param>
             <returns>an array of imported class names</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.ImportSchema(System.String[])">
            <summary> Import the given classes and any dependencies. As part of the
             import, the XEP engine will first try to see if the corresponding
             schema already exists on the IRIS side. If such schema already
             exists, and it appears to be in sync with the C# schema, import
             will be skipped. Should a schema already exist, but it appears
             different, a check will be performed to see if there is any data.
             If there is no data, a new schema will be generated. If there is
             existing data, an exception will be thrown. Returns an array of
             imported class names.
            
             Since XEP needs to know the actual (concrete) runtime types, if
             any fields are declared as interfaces, these fields will be skipped
             (ignored) by XEP by default, unless an implementation of
             InterfaceResolver has been set (by calling setInterfaceResolver).
             For any interfaces whose concrete implementation types are not found
             in the InterfaceResolver, the default behavior is applied (which means
             that the corresponding field will not be projected, nor considered in
             store/load)
             
             This flavor should be used for performance oriented applications.
             The object hierarchy will be fully flattened, and all references
             will be embedded (projected as ObjectScript serial objects). For
             applications that require richer feature set, and better correspondence
             between the C# and ObjectScript object schemas, but are not performance
             critical, one should use importSchemaFull flavor.
            </summary>
            
             <param name="classNames">class names to be imported</param>
             <returns>an array of imported class names</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.DeleteExtent(System.String)">
            <summary>Deletes all objects in the given extent.</summary>
            <param name="className">name of the C# event</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.DeleteClass(System.String)">
            <summary>Deletes a COS class. Deletes only the specified class.
            No dependencies are deleted.</summary>
            <param name="className">name of the class to delete</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.StartTransaction">
            <summary>Start a transaction (which may be a nested transaction)</summary>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Commit">
            <summary>Commit one level of transaction</summary>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Rollback">
            <summary>Rollback all levels of transaction</summary>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.Rollback(System.Int32)">
            <summary>Rollback levelCount levels of transaction, where levelCount is a positive integer.
            Do nothing if levelCount less than or equal to 0, and stop rolling back once transactionLevel 
            reaches 0, if levelCount is greater than initial transactionLevel.
            Note: This method is not supported when connected via TCP/IP.
            </summary>
            <param name="level">transaction level</param>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.GetTransactionLevel">
            <summary>Return current transaction level (0 if not in transaction).</summary>
            <returns> transaction level</returns>
        </member>
        <member name="M:InterSystems.XEP.EventPersister.GetGlobalName(System.String)">
            <summary>Returns the name of the corresponding IRIS global where the data is stored .</summary>
            <param name="className">class name</param>
            <returns>IRIS global name</returns>
        </member>
        <member name="T:InterSystems.XEP.EventQuery`1">
            <summary><CODE>EventQuery</CODE> can be used to retrieve, update and delete
            individual events from the database.
            </summary>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.AddParameter(System.Object)">
            <summary>Binds a parameter.</summary>
            <param name="val">parameter value</param>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.Execute">
            <summary>Execute this XEP query.</summary>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.ExecuteAndFetchAll(System.Int32)">
            <summary>Executes the query and fetches all data. In case of the TCP/IP version 
            and on multi-core machines setting the splitFactor parameter to anything 
            between 3 and the total number of cores should speed up execution as the 
            de-serialization will be done in parallel by using splitFactor cores/threads.
            Otherwise (using in-memory version or setting splitFactor to 2 or less)
            is equivalent to calling Execute followed by calling GetNext in a loop.
            This is also the case when this method is invoked on DotNet version 3.x
            or less, or when a full schema option is selected.</summary>
            <returns>all objects matching the query</returns>
            <param name="splitFactor"> number of threads to use (should be > 2)</param>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.GetNext">
            <summary>Gets the next object.</summary>
            <returns> next object, null if no more objects for this query</returns>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.UpdateCurrent(`0)">
            <summary>Updates the object most recently returned by GetNext().</summary>
            <param name="obj">object to be updated</param>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.DeleteCurrent">
            <summary>Deletes the object most recently returned by GetNext()</summary>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.Close">
            <summary>Closes the query.</summary>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.GetAll">
            <summary>Gets all data in one fell swoop. Can be used to get all data that matches 
            the given query. Can be used only after a query has been executed, and
            cannot be combined with calls to getNext.
            
            IMPORTANT: This is a convenience method. For best performance, if you need to 
            process one element at the time only, always choose getNext instead. There is 
            a high cost associated with maintaining a list of objects.
            </summary>
            <returns>all objects matching the query</returns>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.SetFetchLevel(System.Int32)">
             <summary> Sets the fetch level. By setting fetch level, it is possible to control the 
             amount of data returned. For example, by setting the fetch level to 
             FETCH_LEVEL_DATATYPES_ONLY, objects returned by this query will only have their
             datatype fields set. Any object types, arrays, collections etc. fields will not
             get populated. Using this option can dramatically improve query performance.
             Currently supported fetch levels:
            
             FETCH_LEVEL_ALL - default, all fields populated
             FETCH_LEVEL_DATATYPES_ONLY - only datatype fields filled in
             FETCH_LEVEL_NO_ARRAY_TYPES - all arrays will be skipped
             FETCH_LEVEL_NO_OBJECT_TYPES - all object types will be skipped
             FETCH_LEVEL_NO_COLLECTIONS - all collections will be skipped
             </summary>
             <param name="level">fetch level to be set</param>
        </member>
        <member name="M:InterSystems.XEP.EventQuery`1.GetFetchLevel">
            <summary> Returns the current fetch level.</summary>
            <returns>currently set fetch level</returns>
        </member>
        <member name="T:InterSystems.XEP.InterfaceResolver">
            <summary>
            A call-back mechanism allowing the application to specify the actual (concrete) 
            runtime type for any fields declared as interfaces. This allows the applications 
            to use interface types, but also satisfies the need of the XEP engine to know 
            the concrete types ahead of time.
            </summary>
        </member>
        <member name="M:InterSystems.XEP.InterfaceResolver.GetImplementationType(System.Type,System.String,System.Type)">
            <summary>
            Returns the actual (concrete) runtime type, given a declaring class (optional),
            field name (optional) and the interface type (not optional).
            </summary>
            <param name="declaringClass">declaring class</param>
            <param name="fieldName">field name</param>
            <param name="interfaceClass">interface class</param>
            <returns>actual (concrete) type</returns>
        </member>
        <member name="M:InterSystems.XEP.Internal.XMLClassGenerator.addAttribute(System.String,System.String)">
            XML writes
        </member>
        <member name="T:InterSystems.XEP.PersisterFactory">
            <summary><CODE>PersisterFactory</CODE>. Main XEP entry point. Provides factory 
            method that can be used to produce EventPersister objects.
            </summary>
        </member>
        <member name="M:InterSystems.XEP.PersisterFactory.CreatePersister">
            <summary>Creates a new persister object.</summary>
            <returns> EventPersister instance</returns>
        </member>
        <member name="T:InterSystems.XEP.XEPException">
            <summary><CODE>XEPException</CODE> is thrown by all XEP APIs.</summary>
        </member>
        <member name="M:InterSystems.XEP.XEPException.#ctor(System.Exception,System.String)">
            <param name="x"></param>
            <param name="message"></param>
        </member>
        <member name="M:InterSystems.XEP.XEPException.#ctor(System.String)">
            <param name="message"></param>
        </member>
    </members>
</doc>
